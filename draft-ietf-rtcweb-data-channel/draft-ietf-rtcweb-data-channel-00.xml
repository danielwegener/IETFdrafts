<?xml version="1.0"?>
<?rfc symrefs="yes"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="no" ?>
<?rfc strict="yes" ?>

<rfc ipr="trust200902"
     docName="draft-ietf-rtcweb-data-channel-00.txt" category='info'>
<front>
    <title abbrev="data P2P in RTCWEB">
       RTCWeb Datagram Connection
    </title>


    <author initials="R." surname="Jesup" fullname="Randell Jesup">
      <organization>Mozilla</organization>
      <address>
	<postal>
          <street></street>
	  <code></code> 
	  <city></city> 
	  <country>USA</country>
 	</postal>
	<email>randell-ietf@jesup.org</email>
      </address>
    </author>



   <author initials="S." surname="Loreto" fullname="Salvatore Loreto">
    <organization>Ericsson</organization>
    <address>
    	<postal>
        <street>Hirsalantie 11</street>
        <code>02420</code> 
     	  <city>Jorvas</city> 
    	  <country>Finland</country>
     	</postal>
    	<email>salvatore.loreto@ericsson.com</email>
    </address>
  </author>


    <author initials="M." surname="Tuexen" fullname="Michael Tuexen">
      <organization abbrev='Muenster Univ. of Appl. Sciences'>
                    Muenster University of Applied Sciences</organization>
      <address>
	<postal>
          <street>Stegerwaldstrasse 39</street>
	  <code>48565</code> 
	  <city> Steinfurt</city> 
	  <country>Germany</country>
 	</postal>
	<email>tuexen@fh-muenster.de</email>
      </address>
    </author>



    <date year="2012" />
    <area>RAI</area>
    <workgroup>RTCWeb Working Group</workgroup>
    <keyword></keyword>
    <keyword></keyword>
    <abstract>
    <t>The Web Real-Time Communication (WebRTC) working group is charged to provide
   protocol support for direct interactive rich communication using audio, video,
   and data between two peers' web-browsers.
   This document describes the non-media data transport aspects of the WebRTC framework.
   It provides an architectural overview of how the Stream Control Transmission Protocol (SCTP) is used in
   the WebRTC context as a generic transport service allowing Web Browser to exchange generic data from peer to peer.</t>
    </abstract>
</front>
<middle>

<section title="Introduction">
<t>The issue of how best to handle non-media data types in the context of RTCWEB has  reached a general consensus 
    on the usage of SCPT <xref target="RFC4960"/> encapsulated on DTLS <xref target="RFC6347"/>:</t>

<figure title="Basic stack diagram"
        anchor="fig-stack">
<artwork>
                             +----------+
                             |   SCTP   |
                             +----------+
                             |   DTLS   |
                             +----------+
                             | ICE/UDP  |
                             +----------+
</artwork>
</figure>

<t>The encapsulation of SCTP over DTLS over ICE/UDP provides a NAT traversal solution together with 
confidentiality, source authenticated, integrity protected transfers.  This data transport service operates in parallel to the media transports, and all of them can share a single port.</t>

<t>SCTP provides multiple streams natively with reliable, unreliable and partially-reliable delivery modes.</t>

<t>This document provides requirements and use cases for both unreliable and reliable peer to peer datagram base channel,
provide an overview of how SCTP should be used by the RTCWeb protocol framework for transporting non-media data between browsers.</t>



</section>


<section title="Requirements" anchor="sec-req">

<t>
This section lists the requirements for P2P data connections between two browsers.
</t>

<t>
<list style='format Req. %d'>
<t>Multiple simultaneous datagram streams must be supported.
   Note that there may 0 or more media streams in parallel with the data streams,
   and the number and state (active/inactive) of the media streams may change at
   any time.</t>

   <t>Both reliable and unreliable datagram streams must be supported.</t>

   <t>Data streams must be congestion controlled; either individually,
   as a class, or in conjunction with the media streams, to ensure
   that datagram exchanges don't cause congestion problems for the
   media streams, and that the rtcweb PeerConnection as a whole is
   fair with competing streams such as TCP.</t>

   <t>The application should be able to provide guidance as to the 
   relative priority of each datagram stream relative to each other,
   and relative to the media streams. [ TBD: how this is encoded and
   what the impact of this is. ]  This will interact with the
   congestion control algorithms.</t>

   <t>Datagram streams must be encrypted; allowing for confidentiality,
   integrity and source authentication.
   See the security spec [xxx] for detailed info.</t>

   <t>Consent and NAT traversal mechanism: These are handled by the
   PeerConnection's ICE <xref target="RFC5245"/> connectivity checks and
   optional TURN servers.</t>

   <t>Data streams MUST provide message fragmentation support such that
   IP-layer fragmentation does not occur no matter how large a message
   the Javascript application passes to be sent.</t>

   <t>The data stream transport protocol must not encode local IP addresses
   inside its protocol fields; doing so reveals potentially private information,
   and leads to failure if the address is depended upon.</t>

   <t>The data stream protocol should support unbounded-length "messages"
  (i.e., a virtual socket stream) at the application layer, for such things as
  image-file-transfer; or else it must support at least a maximum
  application-layer message size of 4GB.</t>

   <t>The data stream packet format/encoding must be such
   that it is impossible for a malicious Javascript to generate an
   application message crafted such that it could be interpreted as a native
   protocol over UDP - such as UPnP, RTP, SNMP, STUN, etc.</t>

   <t>The data stream transport protocol must start with the assumption
   of a PMTU of 1280 [ *** need justification ***] bytes until measured
   otherwise.</t>
   <!-- MT: Why? Shouldn't SCTP just do PMTU discovery? -->
   <!-- MT: 1280 is the minimum PMTU for IPv6. However, we need to take
        any IPv6 optional headers, the UDP header (8 bytes) and the DTLS
        overhead (it depends on the choosen cipher suite) into account.
        Same for UPv4. -->

   <t>The data stream transport protocol must not rely on ICMP or ICMPv6
   being generated or being passed back, such as for PMTU discovery.</t>

   <t>It MUST be possible to implement the protocol stack in the user
   application space.</t>
</list>
</t>
</section>


<section title="Use cases." anchor="sec-use-cases">

<section title="Use cases for unreliable datagram based channel"
         anchor="sec-use-cases-unreliable">

<t>
<list style='format U-C %d' counter='UseCases'>

   <t>A real-time game where position and object state information is
   sent via one or more unreliable data channels.
   Note that at any time there may be no media channels, or all media channels
   may be inactive, and that there may also be reliable data channels in use.</t>
	
   <t>Non-critical state updates about a user in a video chat or 
   conference, such as Mute state.</t>
</list>
</t>


</section>

<section title="Use cases for reliable channels (datagram or stream)."
         anchor="sec-use-cases-reliable">

<t>Note that either reliable datagrams or streams are possible;
reliable streams would be fairly simple to layer on top of SCTP reliable
datagrams with in-order delivery.</t>

<t>
<list style='format U-C %d' counter='UseCases'>

   <t> A real-time game where critical state information needs to be
   transferred, such as control information.  Typically this would be datagrams.
   Such a game may have no media channels, or they may be inactive at any
   given time, or may only be added due to in-game actions.</t>
	
   <t>Non-realtime file transfers between people chatting.
   This could be datagrams or streaming.  Note that this may involve a large
   number of files to transfer sequentially or in parallel, such as when
   sharing a folder of images or a directory of files.</t>

   <t>Realtime text chat while talking with an individual or with multiple
   people in a conference. Typically this would be datagrams.</t>

   <t>Renegotiation of the set of media streams in the PeerConnection.
   Typically this would be datagrams</t>

   <t>Proxy browsing, where a browser uses data channels of a PeerConnection
   to send and receive HTTP/HTTPS requests and data, for example to avoid local
   internet filtering or monitoring. Typically this would be streams.</t>
</list>
</t>
</section>


</section>



<section title="Datagrams over SCTP over DTLS over UDP." anchor="sec-p-a-2">

<figure title="stack diagram"
        anchor="fig-2">
<artwork>
                                  +------+
                                  |WEBAPP|
                                  +------+
                                  | SCTP |
                           +-------------+
                           | STUN | DTLS |
                           +-------------+
                           |     ICE     |
                           +-------------+
                           | UDP1 | UDP2 |
                           +-------------+
</artwork>
</figure>

<t>An SCTP <xref target="RFC4960"/> based solution provides natively several interesting features for transporting non-media data between browsers:</t>
<t>
<list style="empty">
<t>Multistreaming</t> 
<t>Ordered and Unordered delivery</t>
<t>Reliability and partial-Reliability <xref target="RFC3758"/></t>
</list></t>

<t>Moreover SCTP provides the possibility to transport different "protocols" over multiple streams and associations using the ppid (Payload Protocol Identifier). 
An application can set a  different PPID with each send call. This allows the receiving application to look at this information (as well as the stream id/seq) on receiving
to know what type of protocol the data payload has.</t>

<t>The SCTP features satisfy all the requirements listed in in <xref target='sec-req'/>.</t>

<t>There are SCTP implementations for most Operating Systems in wide use:</t>
<t>
<list style="empty">
<t>Linux (mainline kernel 2.6.36)</t>
<t>FreeBSD (release kernel 8.2)</t>
<t>Mac OS X</t> 
<t>Windows (SctpDrv4)</t> 
<t>Solaris (OpenSolaris 2009.06)</t>
<t>and a user-land SCTP implementation (based on the FreeBSD implementation).</t>
</list></t>

<t>The SCTP solution is analyzed in more detail in the following sections.</t>




<section title="User Space vs Kernel implementation." anchor="sec-sctp-1">
<t>Even though kernel implementations of SCTP are already available for most platforms (see <xref target='sec-p-a-2'/> ),
there are compelling reasons for using an SCTP stack that works well in user land.</t>

<t>The main reason is deployability.</t>

<t>Web browsers supporting WebRTC are expected to run on a wide range of old and new operating systems. They support operating systems 10 years old or more, they run on mobile and desktop operating systems, 
and they are highly portable to new operating systems. This is achieved by having a fairly narrow portability layer to minimize what needs 
to be supported on old operating systems and ported to new ones. This creates a need to implement as much functionality as possible 
inside the application instead of relying on the operating system.</t>

<t>As a user-land implementation of SCTP is available, this meets requirement 12.</t>


</section>




<section title="SCTP/DTLS/UDP layering" anchor="sec-sctp-3">
<t>The layering of protocols for WebRTC is shown here <xref target='fig-sctp-layering'/>.</t>
<figure title='WebRTC protocol layers'
        anchor='fig-sctp-layering'>
<artwork>
                                     +------+
                                     |WEBAPP|
                                     +------+
                                     | SCTP |
                       +--------------------+
                       | STUN | SRTP | DTLS |
                       +--------------------+
                       |         ICE        |
                       +--------------------+
                       | UDP1 | UDP2 | ...  |
                       +--------------------+
</artwork>
</figure>
<t>Considering the protocol stack on the right hand side of
<xref target='fig-sctp-layering'/>, the usage of DTLS over UDP is specified in
<xref target='I-D.ietf-tls-rfc4347-bis'/>. Using SCTP on top of DTLS is
currently unspecified, but a draft is being prepared for the TSVWG.
Since DTLS is typically implemented in user-land,
an SCTP user-land implementation must also be used. 
When using DTLS as the lower layer, only single homed SCTP
associations can be used, since DTLS does not expose any any address management
to its upper layer. The ICE/UDP layer can handle IP address changes during a 
session without needing to notify the DTLS and SCTP layers, though it would 
be advantageous to retest path MTU on an IP address change.</t>

<t>DTLS implementations used for this stack must support
controlling fields of the IP layer like the DF-bit in case of IPv4 and the
DSCP field. This is required for performing path MTU discovery.
The DTLS implementation must also support sending user messages exceeding
the path MTU. When supporting multiple SCTP associations over a single DTLS
connection, incoming ICMP or ICMPv6 messages can't be processed by the SCTP
layer, since there is no way to identify the corresponding association.
Therefore the number of SCTP associations should be limited to one or ICMP and
ICMPv6 messages should be ignored.
In general, the lower layer interface of an SCTP implementation has to be
adapted to address the differences between IPv4 or IPv6 (being connection-less)
or DTLS (being connection-oriented).
When this stack is used, DTLS protects the complete SCTP packet, so it
provides confidentiality, integrity and source authentication
of the complete SCTP packet.</t>

<t>This protocol supports the usage of
multiple SCTP streams. A user message can be sent ordered or unordered
and, if the SCTP implementations support <xref target='RFC3758'/>,
with partial reliability. When using partial reliability, it might make
sense to use a policy limiting the number of retransmissions. Limiting
the number of retransmissions to zero provides a UDP like service where
each user messages is sent exactly once.</t>

<t>SCTP provides congestion control on a per-association base. This means
that all SCTP streams within a single SCTP association share the same
congestion window. Traffic not being sent over SCTP is not covered by
the SCTP congestion control.  Due to the typical parallel SRTP media
streams, it will be advantageous to select a delay-sensitive congestion
control algorithm or to at least coordinate congestion control between the
data channels and the media streams to avoid a data channel transfer 
ending up with most or all the channel bandwidth.</t>
</section>


</section>

<section title="The envisioned usage of SCTP in the RTCWeb context" anchor="sec-sctp-usage">
<t>The appealing features of SCTP in the RTCWeb context are:</t>
<t><list style="hanging">
   <t hangText="-">TCP-friendly congestion control.</t>
   <t hangText="-">the congestion control is modifiable for integration with media stream congestion control.</t>
   <t hangText="-">support for multiple channels with different characteristics.</t>
   <t hangText="-">support for out-of-order delivery.</t>
   <t hangText="-">support for large datagrams and PMTU-discovery and fragmentation.</t>
   <t hangText="-">reliable or partial reliability support.</t>
   <t hangText="-">Multi streaming.</t>
</list></t>

<t>Multihoming will not be used in this scenario. The SCTP layer would simply act 
as if it were running on a single-homed host, 
since that is the abstraction that the lower layers (e.g. UDP) would expose.</t>

<section title="Association setup" anchor="sec-sctp-setup">
<t>The SCTP association would be set up when the two endpoints of the WebRTC 
PeerConnection agree on opening it, as negotiated by JSEP (typically an 
exchange of SDP).  It would use the DTLS connection created at the start of the PeerConnection connection</t>

<t>The application should indicate the number of simultaneous streams 
required when opening the association, and if no value is supplied the 
implementation should provide a default, with suggested value of 16.  
If more simultaneous streams are needed, <xref target="RFC6525"/> allows 
adding additional (but not removing) streams to an existing association.</t>

</section>


<section title="Channel definition">
<t>SCTP defines a Stream as an unidirectional logical channel established from one to
another associated SCTP endpoint.
It is also worth to mention that the relationship between stream numbers in opposite directions
is strictly a matter of how the applications use them.  It is the responsibility of the SCTP user 
to create and manage these correlations if they are so desired. </t>

<t>A Bidirectional Data Channel is a relationship of one incoming stream and one outcoming stream.  The W3C seems to have consensus on defining the application API for WebRTC dataChannels to be bidirectional.</t>
</section>

<section title="SCTP streams">
<t>TBD not sure if we want discuss here or in the actual protocol draft:</t>
<t><list style="empty">
<t>signaling the close of a stream resetting the Stream Sequence Numbers (SSN) in a stream to 00</t>
<t>the fact that all the control message will be transported on stream 0 and usage of stream "0" as 'control stream' vs using
PPID to include the control information directly in the stream. Reliable, unreliable etc. staff is something that will be set
only on the sending side via PPID.</t>
<t>Michael to clarify that "in sequence" or "out of sequence" delivery and "reliable" or "unreliable" transfer are ortoghonal</t>
<t>how to get the out-of-order and loss data for unreliable data from the stack if the JS API is designed to provide those feedback. -- it is expected to be available for non-reliable channels (Randell)</t>
</list></t>

</section>

</section>




<section title="Message Format." anchor="sec-mes-format">

<t> Message type identification shall be done via PPID values; 
values used should be registered.  Currently the types required 
would be WebRTC Control, DOMString and either Binary Data or both
Blob and ArrayBuffer (so either 3 or 4 PPIDs).  For all but WebRTC control,
the datagrams contain only application data.</t>

<t> The WebRTC control PPID indicates the datagram contains control messages.
The format of these messages is as follows: <xref target='fig-control-msg'/></t>

<figure title='WebRTC control messages' anchor='fig-control-msg'>
<artwork>
Open message:
              uint8  msg_type;     // WEBRTC_DATA_MSG_OPEN = 0
	      uint8  channel_type;
	      uint16 flags;
	      uint32 reliability_parameters;
	      uint8  label[];  // DOMString

         'channel_type' contains:
              WEBRTC_DATA_RELIABLE                 1
              WEBRTC_DATA_RELIABLE_STREAM          2
              WEBRTC_DATA_UNRELIABLE               3
              WEBRTC_DATA_PARTIAL_RELIABLE_REXMIT  4
              WEBRTC_DATA_PARTIAL_RELIABLE_TIMED   5

	 'flags' contains:
              WEBRTC_DATA_FLAG_OUT_OF_ORDER_ALLOWED     0x01

Opened message:
              uint8  msg_type;     // WEBRTC_DATA_MSG_OPENED = 1
	      uint8  error;        /* 0 = success,
                                    * 1 = already opened,
                                    * 2 = connection lost,
                                    *     others?
                                    */
	      uint8  reserved[2];
	      uint32 stream_opened;
</artwork>
</figure>

<t> Note that WEBRTC_DATA_MSG_OPEN or OPENED should be the first messages sent on a
stream, or the first messages after a stream sequence number reset.  There can be 
multiple OPENED messages with errors bofore an OPEN or an OPENED with a 0 error.</t>

<t> For WEBRTC_DATA_PARTIAL_RELIABLE_REXMIT and
WEBRTC_DATA_PARTIAL_RELIABLE_TIMED, reliability_parameters holds either the
max number of retransmits or the maximum time in milliseconds to attempt
to deliver data for the channel.</t>

<t> WEBRTC_DATA_FLAG_OUT_OF_ORDER_ALLOWED can be paired with all types other
than WEBRTC_DATA_RELIABLE_STREAM.</t>

<t> 'stream_opened' is the stream number that the WEBRTC_DATA_MSG_OPEN came
in on.  A WebRTC bidirectional channel consists of the forward stream
created by an OPEN on that stream, and a reverse stream created by an
OPENED with a 0 error.</t>

<t> Masking of the protocol is not needed if the lower layer always encrypts with DTLS.</t>


<t> TBD -- we could move all the control messages to a reserved stream (0)
instead of putting them on a PPID on the streams in question.  Both
messages would need to add 'uint32 forward_stream' field.</t>

<t> TBD -- the errors need to be properly thought through and expanded.</t>

</section>


<section title="Security Considerations" anchor="sec-security">
<t>
To be done.
</t>
</section>


<section title="IANA Considerations" anchor="sec-IANA">
<t>
This document does not require any actions by the IANA.
</t>
</section>


<section title="Acknowledgments">
<t>Many thanks for comments, ideas, and text from Cullen Jennings, Eric Rescorla,
Randall Stewart, Justin Uberti, and Harald Alvestrand.</t>
</section>


</middle>

<back>
<references title="Informative References">
<?rfc include="reference.RFC.3758"?>
<?rfc include="reference.RFC.4340"?>
<?rfc include="reference.RFC.4341"?>
<?rfc include="reference.RFC.4342"?>
<?rfc include="reference.RFC.5622"?>
<?rfc include="reference.RFC.4895"?>
<?rfc include="reference.RFC.4960"?>
<?rfc include="reference.RFC.5061"?>
<?rfc include="reference.RFC.5245"?>
<?rfc include="reference.RFC.5389"?>
<?rfc include="reference.RFC.5405"?>
<?rfc include="reference.RFC.6083"?>
<?rfc include="reference.RFC.6347"?>
<?rfc include="reference.RFC.6525"?>
<?rfc include="reference.I-D.ietf-tls-rfc4347-bis"?>
<?rfc include="reference.I-D.ietf-tsvwg-sctp-udp-encaps"?>
<?rfc include="reference.I-D.baset-tsvwg-tcp-over-udp"?>
<?rfc include="reference.I-D.denis-udp-transport"?>
</references>
</back>

</rfc>

<!-- Change log 
Major changes and addition of protocol (to be split out)

-->


